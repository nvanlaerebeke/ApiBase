# Quick Start

This page will contain a quick start sample that does CRUD actions.

## Creating the Application

Create a new ASP.NET Core Web API project.

- Select .NET 6.0 or higher as target framework
- Enable Docker

HTTPS is not required.

## Configure API Startup

The application entry-point needs to have the CreateHostBuilder method, most of the time this is the `Program.cs`  
An example:

```c#
public class Program {
    public static void Main(string[] args) {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) => 
        Host.CreateDefaultBuilder(args).ConfigureWebHostDefaults(webBuilder => webBuilder.UseStartup<Sample.API.Startup>());
}
```

Do not move the code to be run in the Main method as the CreateHostBuilder method is required when running any integration tests.

Create startup class passed in the CreateHostBuilder must be a class that extends the ServerAPI class, this class is responsible to configure the API itself.

```c#
public class Startup : ApiBase.ApiBase
{
    public Startup(IConfiguration configuration) : base(configuration) { }

    protected override void ConfigureApi(IServiceCollection services) {
        _ = services.AddAuthentication("ApiKey").AddScheme<ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler>("ApiKey", null);
        _ = services.AddSingleton<IApiKeyAuthentication>(x => new ApiKeyAuthentication(new ApiKeyProvider()));
        _ = services.AddAutoMapper(typeof(Startup));
    }

    protected override bool ConfigureOpenAPI(IServiceCollection services) {
        return false;
    }

    protected override ApiVersion DefaultVersion() {
        return new ApiVersion(1, 0);
    }

    protected override string GetName() {
        return "Sample API";
    }

    protected override IBadRequestErrorCodeProvider GetBadRequestErrorProvider(){
        return new BadRequestErrorCodeProvider();
    }
}
```

Lets break down the above class, first the 4 smallest methods:

```c#
protected override bool ConfigureOpenAPI(IServiceCollection services) {
    return false; 
}

protected override ApiVersion DefaultVersion() {
    return new ApiVersion(1, 0);
}

protected override string GetName() {
    return "Sample API";
}
protected override IBadRequestErrorCodeProvider GetBadRequestErrorProvider(){
    return new BadRequestErrorCodeProvider();
}
```

The API has a name that will be used, that is returned in the `GetName()` method.  
All API's no matter how small will always have to implement a version, the `DefaultVersion()` method has to return an `ApiVersion` object that says wat version to use as default.  

Next is the OpenAPI(swagger) integration, these docs will be generated by .NET, an example on how to do this will be shown later.  

Last a class that implements `IBadRequestErrorCodeProvider` must be provided, this class will provide the error codes when the API input is incorrect.  

See [ErrorHandling](ErrorHandling.md) for more information.

```c#
protected override void ConfigureApi(IServiceCollection services) {
    _ = services.AddAuthentication("ApiKey").AddScheme<ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler>("ApiKey", null);
    _ = services.AddSingleton<IApiKeyAuthentication>(x => new ApiKeyAuthentication(new ApiKeyProvider()));
    _ = services.AddAutoMapper(typeof(Startup));
}
```

The `ConfigureApi` method has to be implemented to configure all the services, in this example the following is configured:

- API key authentication
- Auto mapping Data object to API Response objects

## OpenAPI

In the previous step the `ConfigureOpenAPI()` was skipped, to auto generate swagger documentation a few steps must be taken.

This is an example from the SampleAPI:

```c#
protected override bool ConfigureOpenAPI(IServiceCollection services) {
    services.AddSwaggerGen(c => {
        c.AddSecurityDefinition("X-API-KEY", new OpenApiSecurityScheme {
            Description = "Api key token validation",
            Name = "X-API-KEY",
            Type = SecuritySchemeType.ApiKey,
            In = ParameterLocation.Header
        });
        c.AddSecurityRequirement(new OpenApiSecurityRequirement() { {
            new OpenApiSecurityScheme {
                Reference = new OpenApiReference {
                    Type = ReferenceType.SecurityScheme,
                    Id = "X-API-KEY"
                },
                Scheme = "X-API-KEY",
                Name = "X-API-KEY",
                In = ParameterLocation.Header
            },
            new List<string>()
        }});
    });
    return true;
}
```

Instead of returning false (meaning do not use OpenAPI) return true is done.  
This will set up the swagger landing page with it's default settings (and versions).  
  
In the example API key authentication was added, for swagger this also needs to be configured.  
The sample code above adds the definition and requirement to the page.

Once this is done you're ready to start creating API endpoints

## Endpoints

In the sample here the CRUD methods will be added as sample.  
Endpoints are classes that inherit from the `ApiBase.Controller.APIController` class.  
  
A simple class with a [GET] request would be:

```c#
[ApiController]
[Authorize(AuthenticationSchemes = "ApiKey")]
[Route("[controller]")]
public class WeatherForecastController : APIController {
    protected readonly IMapper Mapper;
    protected readonly WeatherForecasts Forecasts;

    public WeatherForecastController(IMapper mapper) {
        Mapper = mapper;
        Forecasts = new WeatherForecasts();
    }

    [WeatherForecastGetAuthorization]
    [HttpGet("{id}")]
    public virtual IActionResult Get(string id) {
        var foreCast = Forecasts.Get(id);
        if (foreCast == null) {        {
            return NotFound();
        }
        return Ok(new Response<ForecastResponse>(Mapper.Map<ForecastResponse>(foreCast)));
    }
}
```

## Annotations

The class starts with adding the required annotations:

```c#
[ApiController]
[Authorize(AuthenticationSchemes = "ApiKey")]
[Route("[controller]")]
```

These denote:

- This is an API endpoint
- API key authentication is required for all methods in this class
- Endpoint name is the Controller name, meaning 'WeatherForecast'

## Methods

To implement requests to the endpoint a method with route needs to be configured, example:

```c#
[HttpGet("{id}")]
[WeatherForecastGetAuthorization]
public virtual IActionResult Get(string id) {
    var foreCast = Forecasts.Get(id);
    if (foreCast == null) {
        return NotFound();
    }
    return Ok(new Response<ForecastResponse>(Mapper.Map<ForecastResponse>(foreCast)));
}
```

This method says that all [GET] requests going to `WeatherForecast/<id>` need to be routed to this method.  
Additionally when doing the `Authorization` step the `WeatherForecastGetAuthorization` class is used.

## Authentication/Authorization

### Authentication

In the above example the build-in API key authentication method was used, this was done by adding the `Authorize` attribute.  
The configuration for the authentication was done in the startup by adding the service and making sure the `ApiKeyProvider` is added to the IOC.

### Authorization

Authorization can be added by adding an attribute that implements IAuthorizationFilter and extends the Attribute class.  
In case of API key authorization this is already done for you and a class that extends `ApiKeyAuthorization` can be used for this purpose.  

An example authorization class based on API key:

```c#
internal class WeatherForecastGetAuthorization : ApiKeyAuthorization {
    protected override bool Authorize(IEnumerable<string> roles) {
        return roles.Contains(ApiKeyRole.Controller.ToString());
    }
}
```

The Authorize method is automatically called when a request is done, the roles contain the API key `type`, the the example above if the role is `Controller` it will allow access.

## Responses

Once the work that needs to be done in the endpoint is done an IActionResult must be returned.  
DotNet has a couple of methods that makes this easier for you:

- Ok()
- NotFound()
- BadRequest()

When using ApiBase it is expected that one of the wrapper classes are returned when data needs to be actually sent to the client.  
The wrapper classes provided are:

- Response: return a single or not paginated object/list
- PageResponse: returned a paginated list
- RedirectResponse: sets the 'Location' header for [GET] the passed IAPIObject

Example:

```c$
return Ok(new Response<ForecastResponse>(foreCast));
return Ok(new PageResponse<ForecastResponse>(foreCasts, paginationFilter));
return Redirect(new RedirectResponse<ForecastResponse>(this, foreCast).Url.ToString());
```
